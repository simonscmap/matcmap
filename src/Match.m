% Author: Mohammad Dehghani Ashkezari <mdehghan@uw.edu>
% 
% Date: 2019-12-19
% 
% Function: Class abstraction for matching (colocalizing) variables.
%
%
%
% This calss abstracts the process of matching (colocalizing) a source variable with one or more than one target variables.
% The matching results rely on the spatio-temporal tolerance parameters.
% Notice the source has to be a single variable and cannot be a climatological variable. 
% You may pass empty string ('') as source variable if you only want to get the time and location info from the source table.
% The target variables (one or more) are matched with the source variable, if any match exists.
% Please note that the number of matching entries between each target variable and the source variable might vary depending on the temporal and spatial resolution of the target variable. 


classdef Match
    properties
        spname
        sourceTable
        sourceVariable
        targetTables
        targetVariables
        dt1
        dt2
        lat1
        lat2 
        lon1 
        lon2 
        depth1 
        depth2
        timeTolerance
        latTolerance
        lonTolerance
        depthTolerance                            
    end    
    
    methods
        function self = Match(...
                             spname,...
                             sourceTable,...
                             sourceVariable,...
                             targetTables,...
                             targetVariables,...
                             dt1,... 
                             dt2,... 
                             lat1,... 
                             lat2,... 
                             lon1,... 
                             lon2,... 
                             depth1,... 
                             depth2,...
                             timeTolerance,...
                             latTolerance,...
                             lonTolerance,...
                             depthTolerance...                            
                             )
            % Match constructor method.
            % :param str spname: stored procedure name that executes the matching logic.
            % :param str sourceTable: table name of the source data set.
            % :param str sourceVariable: the source variable. The target variables are matched (colocalized) with this variable.
            % :param cell array targetTables: table names of the target data sets to be matched with the source data.
            % :param cell array targetVariables: variable names to be matched with the source variable.
            % :param str dt1: start date or datetime.
            % :param str dt2: end date or datetime.
            % :param float lat1: start latitude [degree N].
            % :param float lat2: end latitude [degree N].
            % :param float lon1: start longitude [degree E].
            % :param float lon2: end longitude [degree E].
            % :param float depth1: start depth [m].
            % :param float depth2: end depth [m].
            % :param cell array timeTolerance: float list of temporal tolerance values between pairs of source and target datasets. The size and order of values in this list should match those of targetTables. If only a single integer value is given, that would be applied to all target datasets. This parameter is in day units except when the target variable represents monthly climatology data in which case it is in month units. Notice fractional values are not supported in the current version.
            % :param cell array latTolerance: float list of spatial tolerance values in meridional direction [deg] between pairs of source and target data sets. If only one value is given, that would be applied to all target data sets.
            % :param cell array lonTolerance: float list of spatial tolerance values in zonal direction [deg] between pairs of source and target data sets. If only one value is given, that would be applied to all target data sets.
            % :param cell array depthTolerance: float list of spatial tolerance values in vertical direction [m] between pairs of source and target data sets. If only one value is given, that would be applied to all target data sets.
            
            self.spname = spname;
            self.sourceTable = sourceTable;
            self.sourceVariable = sourceVariable;
            self.targetTables = targetTables;
            self.targetVariables = targetVariables;
            self.dt1 = dt1;
            self.dt2 = dt2;
            self.lat1 = lat1;
            self.lat2 = lat2;
            self.lon1 = lon1;
            self.lon2 = lon2;
            self.depth1 = depth1;
            self.depth2 = depth2;
            self.timeTolerance = timeTolerance;
            self.latTolerance = latTolerance;
            self.lonTolerance = lonTolerance;
            self.depthTolerance = depthTolerance;
            
            % TODO: add input validation, a la pycmap
        end
        

        
        function tbl = compile(self)
            % Loops through the target data sets and match them with the source data set according to the the accosiated tolerance parameters.
            % Returns a compiled table of the source and matched target data sets.
            function shifted = shift_dt(dt, delta)
                delta = double(delta);
                dtFormat = 'yyyy-MM-dd';
                if contains(dt, 'T')
                    dt = strrep(dt, 'T', ' ');
                    if contains(dt, '.000Z')
                        dt = strrep(dt, '.000Z', '');
                    end                            
                    dtFormat = 'yyyy-MM-dd HH:mm:SS';
                end
                dt = datetime(dt, 'InputFormat', dtFormat);
                dt = dt + days(delta);
                % TODO: Handle monthly climatology data sets
                shifted = datestr(dt, 'yyyy-mm-dd HH:MM:SS');
            end
            
            for i = 1:numel(self.targetTables)
                data = self.atomic_match(...
                                         self.spname,... 
                                         self.sourceTable,... 
                                         self.sourceVariable,... 
                                         self.targetTables{i},... 
                                         self.targetVariables{i},... 
                                         shift_dt(self.dt1, -self.timeTolerance{i}),...
                                         shift_dt(self.dt2, self.timeTolerance{i}),...
                                         self.lat1 - self.latTolerance{i},... 
                                         self.lat2 + self.latTolerance{i},... 
                                         self.lon1 - self.latTolerance{i},... 
                                         self.lon2 + self.latTolerance{i},... 
                                         self.depth1 - self.depthTolerance{i},... 
                                         self.depth2 + self.depthTolerance{i},...
                                         self.timeTolerance{i},... 
                                         self.latTolerance{i},... 
                                         self.lonTolerance{i},... 
                                         self.depthTolerance{i}...
                                         );
                if isempty(data)
                    warning('%d: No matching entry associated with %s.', i+1, self.targetVariables{i})
                    continue;
                end    
                fprintf('%d: %s matched.\n', i, self.targetVariables{i})
                
                
                
                
                if i == 1
                    tbl = data;                    
                elseif (...
                      isequal(tbl(:, 1), data(:, 1)) &&... 
                      isequal(tbl.lat(:), data.lat(:)) &&... 
                      isequal(tbl.lon(:), data.lon(:))...
                      )
                    tbl(:, self.targetVariables{i}) = data(:, self.targetVariables{i});
                    tbl(:, strcat(self.targetVariables{i}, '_std')) = data(:, strcat(self.targetVariables{i}, '_std'));
                else
                    fprintf('The matched dataframe corresponding to %s does not have the same size as the first targert variable. Please change the tolerance parameters.\n', self.targetVariables{i})
                end
            end    
        end    
    end
    
    
    methods (Static)
        function tbl = atomic_match(...
                                    spname,...
                                    sourceTable,...
                                    sourceVariable,...
                                    targetTables,...
                                    targetVariables,...
                                    dt1,... 
                                    dt2,... 
                                    lat1,... 
                                    lat2,... 
                                    lon1,... 
                                    lon2,... 
                                    depth1,... 
                                    depth2,...
                                    timeTolerance,...
                                    latTolerance,...
                                    lonTolerance,...
                                    depthTolerance...                            
                                    )
            % Colocalizes the source variable (from source table) with a single target variable (from target table).
            % The tolerance parameters set the matching boundaries between the source and target data sets. 
            % Returns a table containing the source variable joined with the target variable.
            % :param str spname: stored procedure name that executes the matching logic.
            % :param str sourceTable: table name of the source data set.
            % :param str sourceVariable: the source variable. The target variables are matched (colocalized) with this variable.
            % :param str targetTable: table name of the target data set to be matched with the source data.
            % :param str targetVariable: variable name to be matched with the source variable.
            % :param str dt1: start date or datetime.
            % :param str dt2: end date or datetime.
            % :param float lat1: start latitude [degree N].
            % :param float lat2: end latitude [degree N].
            % :param float lon1: start longitude [degree E].
            % :param float lon2: end longitude [degree E].
            % :param float depth1: start depth [m].
            % :param float depth2: end depth [m].
            % :param int timeTolerance: temporal tolerance value between pairs of source and target datasets. The size and order of values in this list should match those of targetTables. If only a single integer value is given, that would be applied to all target datasets. This parameter is in day units except when the target variable represents monthly climatology data in which case it is in month units. Notice fractional values are not supported in the current version.
            % :param float latTolerance: spatial tolerance value in meridional direction [deg] between pairs of source and target data sets. If only one value is given, that would be applied to all target data sets.
            % :param float lonTolerance: spatial tolerance value in zonal direction [deg] between pairs of source and target data sets. If only one value is given, that would be applied to all target data sets.
            % :param float depthTolerance: spatial tolerance value in vertical direction [m] between pairs of source and target data sets. If only one value is given, that would be applied to all target data sets.
            
            queryTemplate = 'EXEC %s ''%s'', ''%s'', ''%s'', ''%s'', ''%s'', ''%s'', ''%s'', ''%s'', ''%s'', ''%s'', ''%s'', ''%s'', ''%s'', ''%s'', ''%s'', ''%s''';
            query = sprintf(queryTemplate,...
                            spname,...
                            string(sourceTable),...
                            string(sourceVariable),...
                            string(targetTables),...
                            string(targetVariables),...
                            string(dt1),... 
                            string(dt2),... 
                            string(lat1),... 
                            string(lat2),... 
                            string(lon1),... 
                            string(lon2),... 
                            string(depth1),... 
                            string(depth2),...
                            string(timeTolerance),...
                            string(latTolerance),...
                            string(lonTolerance),...
                            string(depthTolerance)...                                                        
                           );
            tbl = CMAP.query(query);
        end
    end
end
 
